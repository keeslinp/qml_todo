/* generated by rust_qt_binding_generator */
#include "Bindings.h"

namespace {

    struct option_quintptr {
    public:
        quintptr value;
        bool some;
        operator QVariant() const {
            if (some) {
                return QVariant(value);
            }
            return QVariant();
        }
    };

    struct qstring_t {
    private:
        const void* data;
        int len;
    public:
        qstring_t(const QString& v):
            data(static_cast<const void*>(v.utf16())),
            len(v.size()) {
        }
        operator QString() const {
            return QString::fromUtf8(static_cast<const char*>(data), len);
        }
    };
    typedef void (*qstring_set)(QString*, qstring_t*);
    void set_qstring(QString* v, qstring_t* val) {
        *v = *val;
    }

    struct qmodelindex_t {
        int row;
        quintptr id;
    };
}
extern "C" {
    bool tasks_data_completed(const Tasks::Private*, int);
    bool tasks_set_data_completed(Tasks::Private*, int, bool);
    void tasks_data_title(const Tasks::Private*, int, QString*, qstring_set);
    bool tasks_set_data_title(Tasks::Private*, int, qstring_t);
    void tasks_sort(Tasks::Private*, unsigned char column, Qt::SortOrder order = Qt::AscendingOrder);

    int tasks_row_count(const Tasks::Private*);
    bool tasks_insert_rows(Tasks::Private*, int, int);
    bool tasks_remove_rows(Tasks::Private*, int, int);
    bool tasks_can_fetch_more(const Tasks::Private*);
    void tasks_fetch_more(Tasks::Private*);
}
int Tasks::columnCount(const QModelIndex &parent) const
{
    return (parent.isValid()) ? 0 : 1;
}

bool Tasks::hasChildren(const QModelIndex &parent) const
{
    return rowCount(parent) > 0;
}

int Tasks::rowCount(const QModelIndex &parent) const
{
    return (parent.isValid()) ? 0 : tasks_row_count(m_d);
}

bool Tasks::insertRows(int row, int count, const QModelIndex &parent)
{
    return tasks_insert_rows(m_d, row, count);
}

bool Tasks::removeRows(int row, int count, const QModelIndex &parent)
{
    return tasks_remove_rows(m_d, row, count);
}

QModelIndex Tasks::index(int row, int column, const QModelIndex &parent) const
{
    if (!parent.isValid() && row >= 0 && row < rowCount(parent) && column >= 0 && column < 1) {
        return createIndex(row, column, (quintptr)row);
    }
    return QModelIndex();
}

QModelIndex Tasks::parent(const QModelIndex &) const
{
    return QModelIndex();
}

bool Tasks::canFetchMore(const QModelIndex &parent) const
{
    return (parent.isValid()) ? 0 : tasks_can_fetch_more(m_d);
}

void Tasks::fetchMore(const QModelIndex &parent)
{
    if (!parent.isValid()) {
        tasks_fetch_more(m_d);
    }
}

void Tasks::sort(int column, Qt::SortOrder order)
{
    tasks_sort(m_d, column, order);
}
Qt::ItemFlags Tasks::flags(const QModelIndex &i) const
{
    auto flags = QAbstractItemModel::flags(i);
    if (i.column() == 0) {
        flags |= Qt::ItemIsEditable;
    }
    return flags;
}

QVariant Tasks::completed(int row) const
{
    QVariant v;
    v = tasks_data_completed(m_d, row);
    return v;
}

bool Tasks::setCompleted(int row, const QVariant& value)
{
    bool set = false;
    set = tasks_set_data_completed(m_d, row, value.value<bool>());
    if (set) {
        QModelIndex index = createIndex(row, 0, row);
        emit dataChanged(index, index);
    }
    return set;
}

QVariant Tasks::title(int row) const
{
    QVariant v;
    QString s;
    tasks_data_title(m_d, row, &s, set_qstring);
    if (!s.isNull()) v.setValue<QString>(s);
    return v;
}

bool Tasks::setTitle(int row, const QVariant& value)
{
    bool set = false;
    set = tasks_set_data_title(m_d, row, value.value<QString>());
    if (set) {
        QModelIndex index = createIndex(row, 0, row);
        emit dataChanged(index, index);
    }
    return set;
}

QVariant Tasks::data(const QModelIndex &index, int role) const
{
    Q_ASSERT(rowCount(index.parent()) > index.row());
    switch (index.column()) {
    case 0:
        switch (role) {
        case Qt::UserRole + 0:
            return completed(index.row());
        case Qt::DisplayRole:
        case Qt::EditRole:
        case Qt::UserRole + 1:
            return title(index.row());
        }
    }
    return QVariant();
}

QHash<int, QByteArray> Tasks::roleNames() const {
    QHash<int, QByteArray> names = QAbstractItemModel::roleNames();
    names.insert(Qt::UserRole + 0, "completed");
    names.insert(Qt::UserRole + 1, "title");
    return names;
}
QVariant Tasks::headerData(int section, Qt::Orientation orientation, int role) const
{
    if (orientation != Qt::Horizontal) {
        return QVariant();
    }
    return m_headerData.value(qMakePair(section, (Qt::ItemDataRole)role), role == Qt::DisplayRole ?QString::number(section + 1) :QVariant());
}

bool Tasks::setHeaderData(int section, Qt::Orientation orientation, const QVariant &value, int role)
{
    if (orientation != Qt::Horizontal) {
        return false;
    }
    m_headerData.insert(qMakePair(section, (Qt::ItemDataRole)role), value);
    return true;
}

bool Tasks::setData(const QModelIndex &index, const QVariant &value, int role)
{
    if (index.column() == 0) {
        if (role == Qt::UserRole + 0) {
            return setCompleted(index.row(), value);
        }
        if (role == Qt::DisplayRole || role == Qt::EditRole || role == Qt::UserRole + 1) {
            return setTitle(index.row(), value);
        }
    }
    return false;
}

extern "C" {
    Tasks::Private* tasks_new(Tasks*,
        void (*)(const Tasks*),
        void (*)(Tasks*, quintptr, quintptr),
        void (*)(Tasks*),
        void (*)(Tasks*),
        void (*)(Tasks*, int, int),
        void (*)(Tasks*),
        void (*)(Tasks*, int, int),
        void (*)(Tasks*));
    void tasks_free(Tasks::Private*);
};

Tasks::Tasks(bool /*owned*/, QObject *parent):
    QAbstractItemModel(parent),
    m_d(0),
    m_ownsPrivate(false)
{
    initHeaderData();
}

Tasks::Tasks(QObject *parent):
    QAbstractItemModel(parent),
    m_d(tasks_new(this,
        [](const Tasks* o) {
            emit o->newDataReady(QModelIndex());
        },
        [](Tasks* o, quintptr first, quintptr last) {
            o->dataChanged(o->createIndex(first, 0, first),
                       o->createIndex(last, 0, last));
        },
        [](Tasks* o) {
            o->beginResetModel();
        },
        [](Tasks* o) {
            o->endResetModel();
        },
        [](Tasks* o, int first, int last) {
            o->beginInsertRows(QModelIndex(), first, last);
        },
        [](Tasks* o) {
            o->endInsertRows();
        },
        [](Tasks* o, int first, int last) {
            o->beginRemoveRows(QModelIndex(), first, last);
        },
        [](Tasks* o) {
            o->endRemoveRows();
        }
)),
    m_ownsPrivate(true)
{
    connect(this, &Tasks::newDataReady, this, [this](const QModelIndex& i) {
        this->fetchMore(i);
    }, Qt::QueuedConnection);
    initHeaderData();
}

Tasks::~Tasks() {
    if (m_ownsPrivate) {
        tasks_free(m_d);
    }
}
void Tasks::initHeaderData() {
    m_headerData.insert(qMakePair(0, Qt::DisplayRole), QVariant("title"));
}
